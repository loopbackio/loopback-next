/// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: @loopback/v3compat
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT

import {
  OperationObject,
  ParameterObject,
  ResponseObject,
  SchemaObject,
  ParameterLocation,
} from '@loopback/rest';
import {
  ParameterOptions,
  RetvalOptions,
  SharedMethod,
  SharedClass,
  RestParameterSource,
} from '../remoting';
import {AssertionError} from 'assert';
import * as debugFactory from 'debug';

const debug = debugFactory('loopback:v3compat:openapi');

export function buildRemoteMethodSpec(
  sharedMethod: SharedMethod,
  verb: string,
  path: string,
  tags: string[] | undefined,
) {
  const defaultSource = verb.toLowerCase() === 'get' ? 'query' : 'form';
  const parameters = convertAcceptsToOpenApi(
    sharedMethod.accepts,
    defaultSource,
  );
  const response = convertReturnsToOpenApi(sharedMethod.returns);
  // TODO: support custom status codes
  // TODO: filter out status/header retvals before deciding the status code
  const statusCode = sharedMethod.returns.length > 0 ? 200 : 204;

  // TODO: ensure the id is unique and we use the same algorithm as in LB3
  const operationId =
    sharedMethod.stringName.replace(/\./g, '_') +
    '__' +
    verb +
    path.replace(/[\/:]+/g, '_');

  const spec: OperationObject = {
    tags,
    summary: sharedMethod.description,
    notes: sharedMethod.notes,
    operationId,
    parameters,
    // TODO: requestBody,
    responses: {
      [statusCode]: response,
    },
  };
  return spec;
}

function convertAcceptsToOpenApi(
  accepts: ParameterOptions[],
  defaultSource: RestParameterSource,
): ParameterObject[] {
  // Filter out parameters that are generated from the incoming request,
  // or generated by functions that use those resources.
  accepts = accepts.filter(function(arg) {
    // Allow undocumenting a param.
    // TODO if (arg.documented === false) return false;
    // Below conditions are only for 'http'
    if (!arg.http) return true;
    // Don't show derived arguments.
    if (typeof arg.http === 'function') return false;
    // Don't show arguments set to the incoming http request.
    // Please note that body needs to be shown, such as User.create().
    if (
      arg.http.source === 'req' ||
      arg.http.source === 'res' ||
      arg.http.source === 'context' ||
      // added in v3compat
      arg.http.source === 'body'
    ) {
      return false;
    }
    return true;
  });

  return accepts.map(a => buildParameterSchema(a, defaultSource));
}

function convertReturnsToOpenApi(returns: RetvalOptions[]): ResponseObject {
  const description = 'Request was successful.';

  const schema: SchemaObject =
    returns.length === 1 && returns[0].root
      ? buildSchemaFromRemotingType(returns[0].type)
      : // TODO: describe the actual return values
        {type: 'object', additionalProperties: true};

  return {
    description,
    content: {
      'application/json': {schema},
    },
  };
}

function buildParameterSchema(
  paramSpec: ParameterOptions,
  defaultSource: RestParameterSource,
): ParameterObject {
  const name = paramSpec.name || paramSpec.arg;
  if (!name) {
    throw new AssertionError({
      message: 'Parameter option "arg" or "name" is required.',
    });
  }

  const httpSource = (paramSpec.http && paramSpec.http.source) || defaultSource;
  if (httpSource === 'form') {
    throw new Error(
      `Parameter source "form" is not supported by OpenAPIv3 and LoopBack4. Param: ${name}.`,
    );
  }

  const schema = buildSchemaFromRemotingType(paramSpec.type);
  debug(
    'Converted param %j type %j into schema %j',
    name,
    paramSpec.type,
    schema,
  );

  const result: ParameterObject = {
    name,
    in: httpSource as ParameterLocation,
    description: paramSpec.description, // TODO: handle arrays/multi-line text
    required: httpSource === 'path' ? true : !!paramSpec.required,
    schema,
  };

  if (schema.type === 'object' && httpSource === 'query')
    result.style = 'deepObject';

  return result;
}

// TODO: replace this with a better implementation.
// Use lib/specgen/schema-builder.js for strong-remoting types
// Consider using @loopback/repository-json-schema for models
function buildSchemaFromRemotingType(
  type: string | [string] | undefined,
): SchemaObject {
  // TODO: handle this edge case in a better way
  if (!type) return {type: 'string'};

  if (Array.isArray(type)) {
    return <SchemaObject>{
      type: 'array',
      items: buildSchemaFromRemotingType(type[0]),
    };
  }

  type = type.toLowerCase();
  switch (type) {
    case 'date':
      return {
        type: 'string',
        format: 'date-time',
      };
    case 'boolean':
    case 'integer':
    case 'number':
    case 'string':
    case 'object':
      return {type};
    case 'any':
      // TODO: find a better schema for "any" object to allow numbers, etc.
      return {type: 'string'};
    default:
      return {type: 'object', additionalProperties: true};
  }
}

export function getClassTags(sharedClass: SharedClass) {
  const tags = [];

  const swaggerSettings =
    (sharedClass &&
      sharedClass.ctor &&
      sharedClass.ctor.settings &&
      sharedClass.ctor.settings.swagger) ||
    {};

  if (swaggerSettings.tag && swaggerSettings.tag.name) {
    tags.push(swaggerSettings.tag.name);
  } else if (sharedClass && sharedClass.name) {
    tags.push(sharedClass.name);
  }

  return tags;
}

export function convertPathFragments(path: string) {
  return path
    .split('/')
    .map(function(fragment) {
      if (fragment.charAt(0) === ':') {
        return '{' + fragment.slice(1) + '}';
      }
      return fragment;
    })
    .join('/');
}

export function convertVerb(verb: string) {
  if (verb.toLowerCase() === 'all') {
    return 'post';
  }

  if (verb.toLowerCase() === 'del') {
    return 'delete';
  }

  return verb.toLowerCase();
}
